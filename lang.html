<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Programming languages</title>
	<link rel="stylesheet" href="./style.css" />
	<link rel="icon" href="./favicon.ico" sizes="any" />
	<!--link rel="icon" href="./icon.svg" type="image/svg+xml" / -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta name="theme-color" content="#241504" />
	<meta name="color-scheme" content="light dark">
<style>
span.pros {
	font-weight: bold;
}
span.cons {
	font-weight: bold;
}
</style>
</head>
<body>
<header>
	<h1>Programming languages</h1>
</header>

<article>
	<p>
	I've recently read Drew DeVault's blog post, <a href="https://drewdevault.com/2019/09/08/Enough-to-decide.html">How I decide between many programming languages</a>. I figured that I should write my own.
	</p>

	<h2>C</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			<a href="https://drewdevault.com/2017/01/30/Lessons-to-learn-from-C.html">Simple</a>.
		</li>
		<li>
			Interoperable with almost all other languages.
		</li>
		<li>
			Direct access to system calls (well, for most system calls that I'd use, anyways).
		</li>
		<li>
			Good ecosystem, and most packages I'd use are in my system's repositories. Using the system package manager is the only way to sanely manage dynamically linked libraries.
		</li>
		<li>
			Flexible macro system. Yes, there are pitfalls, but it's flexible enough for my needs and it's not that hard to remember to add parenthesis.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			Null terminated strings are objectively bad
		</li>
		<li>
			Footguns do exist, and there isn't anything like borrow checking or automatic reference counting. These aren't strictly necessary, but are obviously helpful.
		</li>
		<li>
			<code>errno</code> is bad. (My opinion holds that the proper alternative is multiple return values, though I also believe that the langugage shouldn't make it easy to accidentally ignore errors, nor should error handling have too much boilerplate.)
		</li>
	</ul>


	<h2>Go</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			Easy concurrency to write quick and relatively-scalable network services in.
		</li>
		<li>
			Well-designed standard library, and a generally good ecosystem (with an non-insane language-specific package manager, which I find acceptable since Go libraries are statically linked).
		</li>
		<li>
			The best <a href="https://go.dev/blog/ismmkeynote">garbage collector</a> I've seen in garbage-collected languages.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			<a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang#all-or-nothing-so-let-s-do-nothing">The way zero values are handled are really bad</a>.
		</li>
		<li>
			I'm not a fan of the automatic conversion between pointers and values.
		</li>
		<li>
			<a href="https://drewdevault.com/2014/06/07/Why-Go-error-handling-doesnt-sit-right-with-me.html">Go's error handling doesn't sit right with me</a>. (I am <em>not</em> for exceptions, just to be clear.)
		</li>
	</ul>


	<h2>Python</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			Code is easy to write.
		</li>
		<li>
			Good-ish ecosystem.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			Code is hard to maintain.
		</li>
		<li>
			Really slow.
		</li>
		<li>
			The global interpreter lock guarantees that threading is a pain. <code>asyncio</code> also sucks, and there aren't many libraries written for <code>trio</code>.
		</li>
		<li>
			Dynamically typed, and no, mypy doesn't magically solve everything.
		</li>
	</ul>


	<h2>Shell scripts</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			Good for gluing my desktop together, automating day-to-day tasks (both on the desktop and administering servers), and generating Makefiles.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			A lot of bad advice on the web, and many people write disgusting scripts.
		</li>
		<li>
			Arrays are not available in standard POSIX shell, and life is a pain without them.
		</li>
		<li>
			A sufficiently complex shell script that interacts with the network <em>is</em> going to have remote code execution vulnerabilities.
		</li>
		<li>
			I wanted to say "dynamic typing" here. "No typing" is probably more appropriate.
		</li>
	</ul>


	<h2>Common Lisp</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			Really flexible. Best for, well, list parsing.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			<code>#'i-still-dont-get-the-point-of-having-two-namespaces</code>.
		</li>
		<li>
			Dynamic typing.
		</li>
		<li>
			Quicklisp confuses me.
		</li>
		<li>
			<code>))))))))))))))))))))))</code>
		</li>
	</ul>

	<h2>Lua</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			Probably the best general-purpose scripting language.
		</li>
		<li>
			Easy to use as an extension language.
		</li>
		<li>
			Lua tables are really versatile.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			The lack of real threads is a huge pain. No, coroutines are not threads. (Though, no other scripting language has sane multithreading, so... fair enough.)
		</li>
		<li>
			Generally lacking ecosystem.
		</li>
		<li>
			1-based indexing sucks.
		</li>
		<li>
			I still prefer curly braces over <code>end</code>.
		</li>
	</ul>


	<h2>JavaScript</h2>
	<p><span class="pros">Pros:</span></p>
	<ul>
		<li>
			None. I wouldn't use it if there are saner alternatives in browsers, e.g. if WASM could access the DOM.
		</li>
	</ul>
	<p><span class="cons">Cons:</span></p>
	<ul>
		<li>
			Quirks surrounding automatic type conversion and equality testing.
		</li>
		<li>
			I don't see any compelling reason for this language to exist outside web browsers, yet Node.JS exists.
		</li>
		<li>
			NPM.
		</li>
	</ul>
</article>

<footer>
	<ul role="list">
		<li><a href="./">Home</a></li>
		<li>Runxi Yu</li>
		<li><a rel="license" href="./pubdom.html">Public Domain</a></li>
	</ul>
</footer>
</body>
</html>
